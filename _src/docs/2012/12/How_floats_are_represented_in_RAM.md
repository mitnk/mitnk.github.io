许久之前写了一篇[为什么int和float字节数相同但表示的范围却不同](http://mitnk.com/64/why_int_and_float_have_the_same_size_of_bits_but_have_different_ranges/)

（近日读来，发现读得不是很好，有些地方位置如前后互换再易理解  
不过既已完成就那它保持原样罢，不好也不坏 - -）  

文章里提到了**现代计算机差不多都是基于 IEEE 754 标准来存储浮点数**
并且按理论预测出 `13.625` 在内存的bits是 `0 10000010 10110100000000000000000`  
而 `0.1` 为 `0 01111011 10011001100110011001101`  

前几天想到了一个方法应该可以验证一下事实就是这样的  
今天试了一下，果然没错，至少我用的这台Macbook是这样的  

验证如下：

    :::c
    #include <stdio.h>

    int main()
    {
        float a = 13.625, b = 0.1;
        int *pa = (int *)&a;
        int *pb = (int *)&b;
        printf("%d\n%d\n", *pa, *pb);
    }

输出为：

    1096417280
    1036831949

然后打开Python将这两个整数转换为二进制

    :::python
    In [1]: '{0:032b}'.format(1096417280)
    Out[1]: '01000001010110100000000000000000'

    In [2]: '{0:032b}'.format(1036831949)
    Out[2]: '00111101110011001100110011001101'

Q.E.D.