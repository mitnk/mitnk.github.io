<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="/media/favicon.ico" type="image/x-icon" />
  <link type="text/css" rel="stylesheet" href="/media/css/pygments.css" />
  <link type="text/css" rel="stylesheet" href="/media/css/article.css" />

  <title>C - Compile Make Debug And Document</title>
</head>
<body>

<div id="wrapper">
    <div id="content">
        
<div class="entry">
    <article itemtype="http://schema.org/Blog">
        <h1 class="entry-title">C - Compile Make Debug And Document</h1>
        <div class="entry-content">
            <h2>Link libraries when compiling</h2>
<p>To use a library, you have to tell the compiler that you will be
importing functions from the library twice: once for the compilation and
once for the linker. For a library in a standard location,
the two declarations happen via an <code>#include</code> in the text of the program and
a <code>-l</code> flag on the compiler line.</p>
<div class="highlight"><pre><span class="nv">$ </span>gcc erf.c -o erf -lm -g -Wall -O3 -std<span class="o">=</span>gnu11
<span class="nv">$ </span>gcc -I/usr/local/include use_useful.c -o use_useful -L/usr/local/lib -luseful
</pre></div>
<p><code>-lm</code> tells the linker to link in the math library (math.h). <code>gcc</code> will
implicitly add a <code>-lc</code> at the end of command to link standard
<code>libc</code> library. <code>-g</code> adds symbols for debugging.
<code>-Wall</code> means "set Warnings to ALL". The functions in <code>stdlib.h</code>
and <code>stdio.h</code> have implementations in <code>libc.so</code>
(or <code>libc.a</code> for static linking), which is linked into your executable
by default (as if <code>-lc</code> were specified). <code>GCC</code> can be instructed to avoid
this automatic link with the <code>-nostdlib</code> or <code>-nodefaultlibs</code> options.
<code>-I</code> adds the given path to the include search path. -L adds to
the library search path.</p>
<p>Order matters. If you have a file named specific.o that depends on the
Libbroad library, and Libbroad depends on Libgeneral, then you will need:</p>
<div class="highlight"><pre><span class="nv">$ </span>gcc specific.o -lbroad -lgeneral
</pre></div>
<h3>pkg-config</h3>
<p>Can be installed by <code>brew</code>.</p>
<div class="highlight"><pre><span class="nv">$ </span>pkg-config --libs openssl
-lssl -lcrypto -lz

<span class="nv">$ </span>pkg-config --libs libcurl openssl
-L/usr/local/lib -lcurl -lssl -lcrypto -lz

<span class="nv">$ </span>pkg-config --cflags libcurl
-I/usr/local/include
</pre></div>
<p>Environment Variables in C</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdlib.h&gt; </span><span class="c1">//getenv, atoi</span>
<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">//printf</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">repstext</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"reps"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">repstext</span> <span class="o">?</span> <span class="n">atoi</span><span class="p">(</span><span class="n">repstext</span><span class="p">)</span> <span class="o">:</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"msg"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">"Hello."</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">reps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<h3>Makefile</h3>
<p>(Use <strong>Tabs</strong> install spaces in the file)</p>
<div class="highlight"><pre>P=helloworld
OBJECTS=
CFLAGS = -g -O3 -Wall -Wextra -std=gnu11 -nostdlib -lc
LDLIBS=
CC=gcc

$(P): $(OBJECTS)

clean:
    @rm -f *.{o,out}
    @rm -rf *.dSYM/
    @rm -f $(P)
</pre></div>
<h3>What Are the Linker Flags for Building a Shared Library?</h3>
<p>To tell you the truth, I have no idea. It’s different across operating
systems, both by type and by year, and even on one system the rules are
often hairy. Instead, Libtool, one of the tools introduced in Chapter 3,
knows every detail of every shared library generation procedure on every
operating system. I recommend invest‐ ing your time getting to know
Autotools and thus solve the shared object compilation problem once
and for all, rather than investing that time in learning the right
compiler flags and linking procedure for every target system.</p>
<h3>man</h3>
<p>use man strtok to read about the strtok function, typically including what header to include, the input arguments, and basic notes about its usage. every manual page has a one-line summary, and man -k searchterm will search those summaries. Many systems also have the apropos command, which is similar to man -k. The manual is divided into sections. Section 1 is command-line commands, and section 3 is library functions. If your system has a command-line program named printf, then man printf will show its documentation, and man 3 printf will show the documentation for the C library’s printf command.</p>
<h3>Using Libraries from Source</h3>
<div class="highlight"><pre><span class="nv">$ </span>mkdir ~/root
./configure --prefix<span class="o">=</span><span class="nv">$HOME</span>/root <span class="o">&amp;&amp;</span> make <span class="o">&amp;&amp;</span> make install
</pre></div>
<p>to use:</p>
<div class="highlight"><pre><span class="nv">LDLIBS</span><span class="o">=</span>-L<span class="k">$(</span>HOME<span class="k">)</span>/root/lib <span class="o">(</span>plus the other flags, like -lgsl -lm ...<span class="o">)</span>
<span class="nv">CFLAGS</span><span class="o">=</span>-I<span class="k">$(</span>HOME<span class="k">)</span>/root/include <span class="o">(</span>plus -g -Wall -O3 ...<span class="o">)</span>
</pre></div>
<h2>Debug</h2>
<p>Logic check with GDB, memory leaks check with Valgrind. Linus Torvalds explains: “I use gdb all the time ... as a disassembler on steroids that you can program.” Use the -g flag in the compiler switches, turning off optimization via the -O0 (oh zero) compiler flag, because the optimizer may eliminate variables useful for debugging and shuffle the code in surprising ways. I’ve always found debugging C++ code from the gdb prompt to be painful. Because C code compiles without mangling. On a Mac, you may need to run debug sessions via sudo.</p>
<div class="highlight"><pre><span class="nv">$ </span>sudo pdb a.out
</pre></div>
<p>in your makefile, add:</p>
<div class="highlight"><pre>CFLAGS=-DTest_operations
</pre></div>
<p>The -D flag is the POSIX-standard compiler flag that is equivalent to putting #define Test_operations at the top of every .c file.</p>
<h3>The Stack of Frames</h3>
<p>If your question is just “Where am I?” the easy answer is the line number in the code, and sometimes this is all you need. But more often, your question is “How did I get here?” and the answer, the backtrace or call stack, is a listing of the stack of frames. Here’s a sample backtrace:</p>
<div class="highlight"><pre>#0  0x00413bbe in agent_address (agent_number=312) at addresses.c:100
#1  0x004148b6 in get_agents () at addresses.c:163
#2  0x00404f9b in main (argc=1, argv=0x7fffffffe278) at addresses.c:227
</pre></div>
<h3>Valgrind</h3>
<div class="highlight"><pre>$ valgrind your_program
</pre></div>
<p>You can also start the debugger at the first error, by running:</p>
<div class="highlight"><pre>$ valgrind --db-attach=yes your_program
</pre></div>
<p>Valgrind also does memory leaks:</p>
<div class="highlight"><pre>$ valgrind --leak-check=full your_program
</pre></div>
<p>This is typically slower, so you might not want to run it every time.</p>
<h2>Unit Testing</h2>
<p>Use <a href="https://developer.gnome.org/glib/">GLib</a>''s Test framework to do unit testing.</p>
<h2>Documentation</h2>
<ul>
<li>Doxygen</li>
<li>Graphviz</li>
<li>CWEB</li>
</ul>
<h2>Three types of memory; three bundles of features</h2>
<div class="highlight"><pre>+------------------------------------+--------+------+--------+
|                                    | Static | Auto | Manual |
+------------------------------------+--------+------+--------+
| Set to zero on startup             | Y      |      |        |
|                                    |        |      |        |
| Scope-limited                      | Y      | Y    |        |
|                                    |        |      |        |
| Can set value on init              | Y      | Y    |        |
|                                    |        |      |        |
| Can set nonconstant values on init |        | Y    |        |
|                                    |        |      |        |
| sizeof measures array size         | Y      | Y    |        |
|                                    |        |      |        |
| Persists across function calls     | Y      |      | Y      |
|                                    |        |      |        |
| Can be global                      | Y      |      | Y      |
|                                    |        |      |        |
| Array size can be set at runtime   |        | Y    | Y      |
|                                    |        |      |        |
| Can be resized                     |        |      | Y      |
|                                    |        |      |        |
| Jesus weeps                        |        |      | Y      |
+------------------------------------+--------+------+--------+
</pre></div>
<h2>C Pointers</h2>
<p>When a program runs across this declaration in your code:</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">an_array</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</pre></div>
<p>the program will:</p>
<ul>
<li>set aside a space on the stack big enough for 32 integers,</li>
<li>declare that an_array is a pointer, and</li>
<li>bind that pointer to point to the newly allocated space.</li>
</ul>
<p>When a program runs across this declaration in your code:</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">a_pointer</span><span class="p">;</span>
</pre></div>
<p>the program will only do one of the above steps:</p>
<ul>
<li>declare that an_array is a pointer</li>
</ul>
<p>This pointer is not bound to any specific location in memory, and so is free to be
assigned to point to anywhere. Valid uses include:</p>
<div class="highlight"><pre><span class="c1">//manually allocating a new block; pointing a_pointer to it:</span>
<span class="n">a_pointer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="c1">//pointing the pointer to an_array, as declared above.</span>
<span class="n">a_pointer</span> <span class="o">=</span> <span class="n">an_array</span><span class="p">;</span>
</pre></div>
<p>In other cases, such as in a typedef declaration (such as for a new struct)
or a function call, there is less distinction to be made:</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a_pointer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">an_array</span><span class="p">[]);</span>
</pre></div>
<p>a_pointer and an_array behave identically.</p>
<p>The Fibonacci sequence generated by a state machine (fibo.c)</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="nf">fibonacci</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">out</span> <span class="o">=</span> <span class="n">first</span><span class="o">+</span><span class="n">second</span><span class="p">;</span>
    <span class="n">first</span><span class="o">=</span><span class="n">second</span><span class="p">;</span>
    <span class="n">second</span><span class="o">=</span><span class="n">out</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%lli</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fibonacci</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
<p>Static variables, even those inside of a function, are initialized when
the program starts, before main, so you can’t initialize them with
a nonconstant value.</p>
<div class="highlight"><pre><span class="c1">//this fails: can't call gsl_vector_alloc() before main() starts</span>
<span class="k">static</span> <span class="n">gsl_vector</span> <span class="o">*</span><span class="n">scratch</span> <span class="o">=</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</pre></div>
<p>This is an annoyance, but easily solved with a macro to start at zero
and allocate on first use:</p>
<div class="highlight"><pre><span class="cp">#define Staticdef(type, var, initialization) \</span>
<span class="cp">    static type var = 0; \</span>
<span class="cp">    if (!(var)) var = (initialization);</span>

<span class="c1">//usage:</span>
<span class="n">Staticdef</span><span class="p">(</span><span class="n">gsl_vector</span><span class="o">*</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">gsl_vector_alloc</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
</pre></div>
<p>This works as long as we don’t ever expect initialization to be zero
(or in pointer- speak, NULL). If it is, it’ll get reinitialized on the
next go-round. Maybe that’s OK any‐ way.</p>
<p>To give another example where malloc sometimes needlessly turns up,
you may have a function that takes in a pointer as input:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Users of the function who too closely associate pointers with malloc
might think that this means that they have to allocate memory to
pass in to the function:</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// so much effort, wasted</span>
<span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">increment</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">free</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</pre></div>
<p>Rather, the easiest use is to let automatic memory allocation do the work:</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">12</span><span class="p">;</span> <span class="n">increment</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
</pre></div>
<h3>Structures Get Copied, Arrays Get Aliased</h3>
<p>Copying the contents of a structure is a one-line operation</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;assert.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">efg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">demo_s</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">demo_s</span> <span class="n">d1</span> <span class="o">=</span> <span class="p">{.</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="p">.</span><span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="p">.</span><span class="n">efg</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="p">[]){</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}};</span>
    <span class="n">demo_s</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">d1</span><span class="p">;</span>
    <span class="n">d1</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
    <span class="n">d1</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">41</span><span class="p">;</span>
    <span class="n">d1</span><span class="p">.</span><span class="n">efg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

    <span class="c1">// all these asserts will pass</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">d2</span><span class="p">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">d2</span><span class="p">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">d2</span><span class="p">.</span><span class="n">c</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">d2</span><span class="p">.</span><span class="n">d</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">d2</span><span class="p">.</span><span class="n">efg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">);</span>

    <span class="c1">// For arrays, the equals sign will copy an alias</span>
    <span class="kt">int</span> <span class="n">abc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="n">abc</span><span class="p">;</span>

    <span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// passes</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"OK.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>when we change d1.efg[0], the change also affects the copy of a pointer
d2.efg. This advises that if you need a deep copy where pointer
contents are copied, you will need a struct copying function, and if
you don’t have any pointers to trace through, then a copy function is
overkill and an equals sign will do.</p>
<p>A function that ends in return x will return the value of x to the
calling function [C99 and C11 §6.8.6.4(3)]. Seems simple enough,
but that value has to be copied out to the calling function, whose frame
is about to be destroyed. As previously, for a struct, a number,
or even a pointer, the calling function will get a copy of the
returned value; for an array, the calling function will get a pointer
to the array, not a copy of the data in the array.</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">powers</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">base</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="n">cube</span><span class="p">;</span>
<span class="p">}</span> <span class="n">powers</span><span class="p">;</span>

<span class="n">powers</span> <span class="nf">get_power</span><span class="p">(</span><span class="kt">double</span> <span class="n">in</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The initialization is via designated initializers</span>
    <span class="n">powers</span> <span class="n">out</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">base</span>   <span class="o">=</span> <span class="n">in</span><span class="p">,</span>
        <span class="p">.</span><span class="n">square</span> <span class="o">=</span> <span class="n">in</span><span class="o">*</span><span class="n">in</span><span class="p">,</span>
        <span class="p">.</span><span class="n">cube</span>   <span class="o">=</span> <span class="n">in</span><span class="o">*</span><span class="n">in</span><span class="o">*</span><span class="n">in</span>
    <span class="p">};</span>
    <span class="c1">// This is valid. On exit, a copy of the local, automatically</span>
    <span class="c1">// allocated out is made, then the local copy is destroyed.</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="o">*</span><span class="nf">get_even</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">out</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
    <span class="c1">// This is invalid. Here, arrays really are treated like pointers,</span>
    <span class="c1">// so on exit, a copy of the pointer to out gets made.</span>
    <span class="c1">// But once the autoallocated memory is destroyed, the pointer is</span>
    <span class="c1">// now pointing to bad data.</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">powers</span> <span class="n">threes</span> <span class="o">=</span> <span class="n">get_power</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"threes: %g</span><span class="se">\t</span><span class="s">%g</span><span class="se">\t</span><span class="s">%g</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">threes</span><span class="p">.</span><span class="n">base</span><span class="p">,</span> <span class="n">threes</span><span class="p">.</span><span class="n">square</span><span class="p">,</span> <span class="n">threes</span><span class="p">.</span><span class="n">cube</span><span class="p">);</span>

    <span class="c1">// evens is a valid pointer-to-int, but it is pointing to</span>
    <span class="c1">// already freed data. This may segfault, print garbage,</span>
    <span class="c1">// or get lucky and print the correct values (this time).</span>

    <span class="c1">// int *evens = get_even(3);</span>
    <span class="c1">// printf("evens: %i\t%i\t%i\n", evens[0], evens[1], evens[2]);</span>
<span class="p">}</span>
</pre></div>
<p>If you need a copy of an array, you can still do it on one line:</p>
<div class="highlight"><pre><span class="cp">#include &lt;assert.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt; </span><span class="c1">// memmove</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">A</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">copy1</span><span class="p">,</span> <span class="n">copy2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="n">copy1</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">copy2</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">copy1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">copy2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"OK.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<h3>malloc and Memory-Twiddling</h3>
<hr/>
<p>Note from: <a href="http://www.amazon.com/gp/product/1491903899/">21st Century C: C Tips from the New School</a></p>
        </div>
    </article>
</div>

    </div>
</div>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-18137446-1']);
  _gaq.push(['_setDomainName', '.mitnk.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>
